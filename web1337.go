/*

Web1337 by KLY

For Golang devs

*/

package web1337

import (
	"encoding/hex"
	"fmt"

	"github.com/KLYN74R/Web1337Golang/crypto_primitives"
)

func Ed25519Process() bool {

	myPubKey, myPrivateKey := crypto_primitives.GenerateEd25519KeyPair()

	fmt.Println("PubKey is ", myPubKey)

	fmt.Println("PrivateKey is ", myPrivateKey)

	signa := crypto_primitives.GenerateEd25519Signature(myPrivateKey, "Hello KLY")

	fmt.Println("Signa is ", signa)

	isOk := crypto_primitives.VerifyEd25519Signature("Hello KLY", myPubKey, signa)

	fmt.Println("Is ok =>", isOk)

	return isOk

}

func BlissProcess() bool {

	myPubKey, myPrivateKey := crypto_primitives.GenerateBlissKeypair()

	fmt.Println("PubKey is ", myPubKey)

	fmt.Println("PrivateKey is ", myPrivateKey)

	signa := crypto_primitives.GenerateBlissSignature(myPrivateKey, "Hello KLY")

	fmt.Println("Signa is ", signa)

	isOk := crypto_primitives.VerifyBlissSignature("Hello KLY", myPubKey, signa)

	fmt.Println("Is ok =>", isOk)

	return isOk

}

func DilithiumProcess() bool {

	myPubKey, myPrivateKey := crypto_primitives.GenerateDilithiumKeypair()

	fmt.Println("PubKey is ", myPubKey)

	fmt.Println("PrivateKey is ", myPrivateKey)

	signa := crypto_primitives.GenerateDilithiumSignature(myPrivateKey, "Hello KLY")

	fmt.Println("Signa is ", signa)

	isOk := crypto_primitives.VerifyDilithiumSignature("Hello KLY", myPubKey, signa)

	fmt.Println("Is ok =>", isOk)

	return isOk

}

func Ted25519Process() bool {

	// This will be generated by one of the group member
	rootPubKey, shares, commitments := crypto_primitives.GenerateTed25519(2, 3)

	fmt.Println("RootPubKey is ", rootPubKey)

	fmt.Println("Shares ", shares)

	fmt.Println("Commitments ", commitments)

	// Then, commitments & rootPubKey is public and shareable. Root pubkey is used as group identifier and wallet address

	// Shares should be sent one-per-user
	// Each of member verify own share using accepted commitments
	ok := crypto_primitives.VerifySecretShareTed25519(2, 3, shares[0], commitments)

	fmt.Println("Share is ", ok)

	msg := hex.EncodeToString([]byte("Hello"))

	// Now, each member(share owner) generate nonce shares & nonce commitments to verify them
	// Each member(or at least T/N) generate nonce shares & nonce commitments for each other

	noncePubKeyFriend1, nonceSharesByFriend1, nonceCommitmentsByFriend1 := crypto_primitives.GenerateNonceSharesTed25519(2, 3, shares[0], rootPubKey, msg)

	noncePubKeyFriend2, nonceSharesByFriend2, nonceCommitmentsByFriend2 := crypto_primitives.GenerateNonceSharesTed25519(2, 3, shares[1], rootPubKey, msg)

	noncePubKeyFriend3, nonceSharesByFriend3, nonceCommitmentsByFriend3 := crypto_primitives.GenerateNonceSharesTed25519(2, 3, shares[2], rootPubKey, msg)

	fmt.Println("**********************************************")

	fmt.Println(noncePubKeyFriend1, nonceSharesByFriend1, nonceCommitmentsByFriend1)

	fmt.Println(noncePubKeyFriend2, nonceSharesByFriend2, nonceCommitmentsByFriend2)

	fmt.Println(noncePubKeyFriend3, nonceSharesByFriend3, nonceCommitmentsByFriend3)

	futureNoncePub := []string{noncePubKeyFriend1, noncePubKeyFriend2, noncePubKeyFriend3}

	// Now each of T/N generate own subsignature

	subsigna1 := crypto_primitives.SubsignTed25519(shares[0], rootPubKey, msg, []string{nonceSharesByFriend1[0], nonceSharesByFriend2[0], nonceSharesByFriend3[0]}, futureNoncePub)

	subsigna2 := crypto_primitives.SubsignTed25519(shares[1], rootPubKey, msg, []string{nonceSharesByFriend1[1], nonceSharesByFriend2[1], nonceSharesByFriend3[1]}, futureNoncePub)

	subsigna3 := crypto_primitives.SubsignTed25519(shares[2], rootPubKey, msg, []string{nonceSharesByFriend1[2], nonceSharesByFriend2[2], nonceSharesByFriend3[2]}, futureNoncePub)

	fmt.Println("**********************[SUBSIGNATURES]************************")

	fmt.Println("Subsigna1: ", subsigna1)
	fmt.Println("Subsigna2: ", subsigna2)
	fmt.Println("Subsigna3: ", subsigna3)

	fmt.Println("**********************[Aggregation]************************")

	signas12 := []map[byte]string{subsigna1, subsigna2}

	aggregatedSignature12 := crypto_primitives.AggregateSubSignaturesTed25519(2, 3, signas12)

	fmt.Println("Aggregation 1 and 2 => ", aggregatedSignature12)

	signas23 := []map[byte]string{subsigna2, subsigna3}

	aggregatedSignature23 := crypto_primitives.AggregateSubSignaturesTed25519(2, 3, signas23)

	fmt.Println("Aggregation 2 and 3 => ", aggregatedSignature23)

	// Finally - verify aggragated signatures

	// is12OK := crypto_primitives.VerifyTed25519(rootPubKey, msg, aggregatedSignature12)

	is23OK := crypto_primitives.VerifyTed25519(rootPubKey, msg, aggregatedSignature23)

	return is23OK

}

type Web1337 struct {
	symbioteID, nodeURL, proxyURL string

	workflowVersion int64
}
